;
; Default configuration file for DEDISbench
;
; Note:	This file will be used if the user doesnt pass
;		a specific file. To pass a specific config file
;		as parameter to DEDISbench use -f<file>
;

[structural]
keep_dbs=0						# option to keep (or not) dbs from previous executions
cleantemp=0						# option to delete (or not) temporary files created by DEDISbench

[execution]
distfile=dist_personalfiles		# Input File with duplicate distribution default:internal file called dist_personalfiles. DEDISbench can simulate three real distributions extracted respectively from an Archival, Personal Files and High Performance Storage; For choosing these distributions the `value` must be dist_archival, dist_personalfiles or dist_highperf respectively. The input file details the amount of blocks with a certain number of duplicates and the format is: <number_duplicates> <number_blocks>
 					        	

access_type=2					# Access pattern for I/O operations: 0-sequential | 1-uniform | 2-TPCC(default)

nprocs=4						# Number of concurrent processes default:4. Each process has an independent file associated or a common device if -i flag is used

filesize=2048					# Size of the file of each process in MB. If rawdevice option is used, this parameter defines the size of the raw device. default:2048 MB

blocksize=4096					# Size of blocks for I/O operations in Bytes default: 4096

populate=0						# Enable or disable the population of process files/device before running DEDISbench: 0-disabled, 1-enabled (with realistic content), 2-enabled (with DD). 
								# Only enabled by default (with value 1) for read and mixed tests).

sync=0							# I/O Operations synchronization (default: 0):  0 - without fsync and O_DIRECT, 1 - O_DIRECT, 2 - fsync, 3 - both.

#rawdevice=path/to/device		# Processes write/read from a raw device instead of having an independent file. If more than one process is defined, each process is assingned with an independent region of the raw device, dependent on the raw device size. By default, if this flag is not set each process writes to an individual file.

#integrity=file					# Enable integrity checks for read requests. The output is written to the specified file. This option also enables a final integrity check done by the benchmark after finishing DEDISbench's workload. Files must be pre-populated with realistic content for read and mixed workloads to ensure that integrity checks are always correct.

#seed=<seed>					# Seed for random generator default:current time. Usefull for repeating

#faulttimer=T:D:TM				# Inject failure at a specific time period, each failure operation must be in the format type_failure:failure_distribution:time_to_inject (minutes). Type of failures are 0 - fill 1 - fill and 2 - fill. Failure distribution: 0 - follow content generation distribution, 1 - inject in the block with more duplicates, 2 - inject in the block with less duplicates, 3 - inject in a block without duplicates.

#faultops=T:D:OP				# Inject failure at a specific number of operations, each failure operation must be in the format type_failurer:failure_distribution:number_operations. Type of failures are 0 - fill 1 - fill and 2 - fill. Failure distribution: 0 - follow content generation distribution, 1 - inject in the block with more duplicates, 2 - inject in the block with less duplicates, 3 - inject in a block without duplicates.


[results]
logging=0						# I/O latency results are written to a log file to extract additional statistics. Each process writes these values in a file called result(processid) and each line, corresponds to a single I/O operations and presents: (latency of I/O operation in microseconds) (current time in seconds).

#output=out						# Write to file path the output of DEDISbench. This feature also writes two additional files with the same name as given in 'out' and a snaplat and snapthr suffix that shows the throughput and latency average values for 30 seconds intervals. It also writes the necessary files to plot a graph of both throughput and latency, with gnuplot.

#outputdist=odist				# generate an output log with the distribution actually generated by the benchmark. This also generates the files needed to plot the distribution with gnuplot.

#accesslog=acessos				# generate an output log with the access pattern generated by the benchmark. This also generates the files needed to plot the accesses to each block, throught time, with gnuplot.

#tempfilespath=./temp			# choose the directory where DEDISbench writes data


